---
category: bookreview
tags: [bookreview, CleanArchitecture]
usemath: [latex]
---

# Chapter 5
## Overview
 저자는 해당 챕터에서 소프트웨어 아키텍처면에서 모든 소스코드 의존성에 대한 절대적인 제어권한을 객체지향(OO)을 통해 얻을 수 있다고 주장한다. OO를 통해 플러그인 아키텍처를 구성하고 고수준의 정책을 포함하는 모듈과 저수준의 세부사항을 포함하는 모듈의 독립성을 보장할 수 있다고 주장한다. 해당 챕터는 객체지향의 세가지 주요 개념인 "캡슐화", "상속", "다형성"을 보이며 "의존성 역전"을 이용하여 아키텍처 수준의 의존성을 제어하고 변경사항에 보다 쉽게 대응할 수 있는 설계를 보인다.

## Key Concepts
"캡슐화", "상속", "다형성", "의존성 역전", "객체지향"

## Review
해당 챕터는 기존에 객체지향을 나타내는 "함수와 데이터의 집합" 또는 "현실세계를 모델링하는 새로운 방법"등의 모호한 정의를 쓰는 대신 객체지향을 씀으로써 얻고자 하는 목표(loosly coupled & highly cohesion)와 이득을 보이며 그 예로 객체지향의 안정적이고 편리하게 다형성을 제공하는 특성을 통해 의존성역전을 어디에서든 일으킴을 보인다. 캡슐화와 상속이 객체지향의 전용 개념이 아니라는 점을 배울 수 있는 챕터였다.

### Dependency injection (의존성 역전)
main 함수가 고수준 함수를 호출하고, 고수준 함수는 다시 중간 수준 함수를 호출하며, 중간 수준 함수는 다시 저수준 함수를 호출한다. 이러한 호출 트리에서 소스 코드 의존성의 방향은 반드시 제어흐름flow of control을 따르게 된다.
main 함수가 고수준 함수를 호출하려면 고수준 함수가 포함된 모듈의 이름을 지정해야만 한다. C의 경우 이러한 지정자는 #include다. 자바에서는 import 구문이다. C#에서는 using 구문이다. 실제로 모든 호출 함수는 피호출 함수가 포함된 모듈의 이름을 명시적으로 지정해야 한다.


하지만 ML1과 I 인터페이스 사이의 소스 코드 의존성(상속 관계)이 제어흐름과는 반대인 점을 주목하자. 이는 의존성 역전dependency inversion이라고 부르며, 소프트웨어 아키텍트 관점에서 이러한 현상은 심오한 의미를 갖는다. OO 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이기도 하다.
 업무 규칙이 데이터베이스와 사용자 인터페이스UI에 의존하는 대신에, 시스템의 소스 코드 의존성을 반대로 배치하여 데이터베이스와 UI가 업무 규칙에 의존하게 만들 수 있다  다시 말해 업무 규칙의 소스 코드에서는 UI나 데이터베이스를 호출하지 않는다. 결과적으로 업무 규칙, UI, 데이터베이스는 세 가지로 분리된 컴포넌트 또는 배포 가능한 단위(예를 들면 jar 파일, DLL, Gem 파일 등)로 컴파일할 수 있고, 이 배포 단위들의 의존성 역시 소스 코드 사이의 의존성과 같다.
  특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다. 이것이 바로 배포 독립성(independent deployability)이다.
시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있다. 그리고 이것이 개발 독립성(independent developability)이다.
### Encapsulation (캡슐화)
 oo에서 중요한 개념으로 여겨지는 캡슐화가 사실은 다른 언어 (C)등에서 더욱 완벽하게 구현이 가능하면 실제로 많은 OO 언어들은 캡슐화 개념을 훼손하는 쪽으로 만들어 졌음을 보인다. 
### Inheritance (상속)
작가의 상속의 정의 : 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다. OO언어에서 새롭게 등장한 개념이라기 보다 기존에 C,C++에서 프로그래머들이 행하던 비슷한 기법을 보다 편리하게 만들어주고 업캐스팅을 강제한다.
### Polymorphism (다형성)
이 말이 완전히 옳은 말이 아니긴 하다. OO 언어는 다형성을 제공하지는 못했지만, 다형성을 좀 더 안전하고 더욱 편리하게 사용할 수 있게 해준다.함수에 대한 포인터를 직접 사용하여 다형적 행위를 만드는 이 방식에는 문제가 있는데, 함수 포인터는 위험하다는 사실이다. 이러한 기법은 프로그래머가 특정 관례를 수동으로 따르는 방식이다. 즉, 이들 포인터를 초기화하는 관례를 준수해야 한다는 사실을 기억해야 한다. 그리고 이들 포인터를 통해 모든 함수를 호출하는 관례를 지켜야 한다는 점도 기억해야 한다. 만약 프로그래머가 관례를 지켜야 한다는 사실을 망각하게 되면 버그가 발생하고, 이러한 버그는 찾아내고 없애기가 지독히도 힘들다


