---
category: bookreview
tags: [bookreview, CleanArchitecture]
usemath: [latex]
---

# Chapter 11
## Overview
 저자는 해당 챕터에서  범용적인 관점에서 "응집도"는 높이고 "결합도"를 낮추기 위해 (이를 통해 SW가 변경에  대응하기 쉬운 유연한 설계를 지닐 수 있다) DIP를 사용하는 것을 보인다.

## Key Concepts
"DIP", "의존성 역전 원칙", "객체지향"

## Review
해당 챕터의 논점을 벗어나지만 SW의 성숙도가 어느정도 이르렀을 때 변하지 않을 부분이나 변해서는 안되는 부분을  상속을 사용하여 구현하게끔 설계를 하면 후에 들어온 개발자의 실수를 줄일 수 있지 않나 운영 관점에서 고민하게 되었다..

### 안정된 추상화를 위한 실천법


#### 변동성이 큰 구체 클래스를 참조하지 말라 대신 추상 인터페이스를 참조하라

객체 생성방식을 강하게 제약하며 일반적으로 추상 팩토리를 사용하도록 강제한다. -> 추상 팩토리를 사용하면 불리한 예를 조사할 것

#### 변동성이 큰 구체 클래스로 부터 파생하지 말라
정적 타입 언어에서 상속은 소스코드에 존재하는 모든 관계중에 가장 강력하고 뻣뻣해서 변경하기 어렵다. 상속에 대한 경고라고 생각이 된다. 해당 챕터는 개발 초기 단계에 변경점이 많을 것으로 생각되는 모듈을 위한 설계에 대해 설명하고 있다.


#### 구체 함수를 오버라이드 하지 말라
대체로 구체 함수는 소스 코드 의존성을 필요로 하기 때문에 구체 함수를 오버라이드 하면 소스 코드 의존성을 상속하게 된다. 저자는 구체함수를 오버라이드 하는 대신에 추상 함수를 선언하고 구현체들에서 각자의 용도에 맞게 구현할 것을 주장한다.

#### 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라


### 팩토리
"추상 팩토리"를 설명한다. 아키텍처 상에서 추상적인 부분과 구체적인 부분을 나누는 아키텍처 경계를 보여주며 소스코드 의존성이 해당 곡선과 교차할 때 의존성 역전이 일어나고 있음을 보인다.(저자가 주장하는 좋은 설계)
### 구체 컴포넌트
해당 장에서 DIP를 위배하는 클래스가 생기는것은 대부분의 경우가 생기며 모두 없앨 수 없음을 설명한다. 또한 DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고 이를 통해 시스템의 나머지 부분과는 분리할 수 있다고 주장한다. DIP를 통해 변경이 일어날 때 영향을 받는 부분을 최소화 하고 또한 집중 시키는 설계를 할 수 있음을 보인다. 

